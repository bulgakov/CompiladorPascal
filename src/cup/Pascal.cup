package compiladorpascal;
import java_cup.runtime.*;
import java.util.List;
import java.util.ArrayList;
import ast.*;
import table.ErrorMsg;

/* Inicializacion  */
parser code {: 
    private List<ErrorMsg> errors = new ArrayList<ErrorMsg>();

    public void report_error(String message, Object info) {       
        /* Alt error print */
        /*
        System.err.print(message);
        System.err.flush();
        if (info instanceof Symbol)
	    if (((Symbol)info).left != -1)
	        System.err.println(" at line " + ((Symbol)info).left +
                                   " of input");
	    else System.err.println("");
        else System.err.println("");
        */
        /*
        System.out.println(message+" at");
        if ( info instanceof ComplexSymbolFactory.ComplexSymbol )
            System.out.println(info);
        else 
            System.err.println("Error : " + message);
        */
        StringBuilder err = new StringBuilder();
        err.append(message);
        err.append(" Expected: ");
        for (Integer i : expected_token_ids()) { 
            if (err.length() != 0) 
                err.append(", ");
            err.append(symbl_name_from_id(i));
        }
        if (info != null && info instanceof ComplexSymbolFactory.ComplexSymbol)
            errors.add(new ErrorMsg(((ComplexSymbolFactory.ComplexSymbol)info).xleft.getLine(), ((ComplexSymbolFactory.ComplexSymbol)info).xleft.getColumn(), err.toString()));
        else
            errors.add(new ErrorMsg(0, 0, err.toString()));
    }
    
    public List<ErrorMsg> getErrors() { 
        return errors;
    }

    public boolean error() { 
        return errors.size() > 0;
    }
:};

/* Terminales */
terminal WRITE
terminal READ

terminal DOT;
terminal COMMA;
terminal SEMICOLON;
terminal COLON;
terminal LPAREN;
terminal RPAREN;

/* procedimientos y funciones */
terminal PROGRAM;
terminal PROCEDURE;
terminal FUNCTION;
terminal BEGIN;
terminal END;
terminal RETURN;
terminal TYPE;
terminal RECORD;


/* secuencias de control e iteradores */
terminal IF;
terminal THEN;
terminal ELSE;
terminal FOR;
terminal TO;
terminal DO;
terminal WHILE;
terminal REPEAT;
terminal UNTIL;
terminal BREAK;
terminal CONTINUE;
terminal EXIT;

/* Tipos */
terminal CHAR, INTEGER, BOOLEAN;

/* Operadores */
terminal ASSIGN;            // :=
terminal String EQ;         // =
terminal String NEQ;        // <>
terminal String LT;         // <
terminal String GT;         // >
terminal String LE;         // <=
terminal String GE;         // >=
terminal String PLUS;       // +
terminal String MINUS;      // -
terminal String MULT        // *
terminal String SLASH;      // /
terminal NOT;               //not
terminal DIV;               //div
terminal MOD;               //mod

/* literales */
terminal NIL;
terminal FALSE, TRUE;
terminal String  IDENTIFIER;
terminal String  STRING_LITERAL;
terminal Char    CHAR_LITERAL;
terminal Integer INTEGER_LITERAL;

/* No-Terminales */
non terminal Program prog;
non terminal Parameters parameters;
non terminal IdentifierList identifier_list;
non terminal Block block;
non terminal Declarations declarations;
non terminal Declaration declaration;
non terminal TypeDeclaration type_declaration;
non terminal TypeDefinitions type_definitions;
non terminal TypeDefinition type_definition;
non terminal RecordType record_type;
non terminal FieldList field_list;
non terminal VariableDeclaration variable_declaration;
non terminal VariableDefinitions variable_definitions;
non terminal VariableDefinition variable_definition;
non terminal ProcedureDeclaration procedure_declaration;
non terminal FunctionDeclaration function_declaration;
non terminal FormalParamaters formal_parameters;
non terminal ParameterDefs parameter_defs;
non terminal ParameterDef parameter_def;
non terminal Statement statements;
non terminal Statement statement;
non terminal Statement assign_statement;
non terminal Statement procedure_statement;
non terminal Statement if_statement;
non terminal Statement else_statement;
non terminal Statement while_statement;
non terminal Statement repeat_statement;
non terminal Statement for_statement;
non terminal ParameterList parameter_list;
//non terminal Parameter parameter;
non terminal Expression opt_expression;
non terminal Expression expression;
non terminal Expression relation;
non terminal Expression simple_expression;
non terminal Expression term;
non terminal Expression factor;
non terminal Expression primary;
non terminal Expression name;
non terminal Type type;
non terminal String OPLOG;      // and or
non terminal String OPREL;      // = <> < <= > >=
non terminal String OPSUM;      // + -
non terminal String OPMULT;     // * / mod div
non terminal Type type_simple;

/* Precedencia */

/* Gramatica */
start with prog;

prog                        ::= PROGRAM:p IDENTIFIER parameters:pd block DOT
                            {: RESULT = new Program(p, pxleft.getLine(), pxleft.getColumn()); :}
                            ;

parameters                  ::= LPAREN identifier_list RPAREN
                            |   
                            ;

identifier_list             ::= IDENTIFIER:i
                            |   IDENTIFIER:i COMMA identifier_list:il
                            ;

block                       ::= declarations:dl BEGIN:b statements:s END:e
                            ;

declarations                ::= declaration:d declarations:dl
                            |   
                            ;

declaration                 ::= variable_declaration:vl
                            |   type_declaration:tl
                            |   procedure_declaration:p
                            |   function_declaration:f
                            ;

type_declaration            ::= TYPE:t type_definitions:tl
                            ;

type_definitions            ::= type_definition:t SEMICOLON:s type_definitions:tl
                            |   type_definition:t SEMICOLON:s
                            ;

type_definition             ::= IDENTIFIER:i EQ:e record_type
                            ;

record_type                 ::= RECORD:r field_list:fl END:e
                            ;

field_list                  ::= identifier_list:il COLON:c type:t field_list:fl
                            |   
                            ;

variable_declaration        ::= VAR variable_definitions:vl

variable_definitions        ::= variable_definition:v SEMICOLON:s
                            |   variable_definition:v SEMICOLON:s variable_definitions:vl
                            ;   

variable_definition         ::= identifier_list:il COLON:c type:t
                            ;

procedure_declaration       ::= PROCEDURE:p IDENTIFIER:i formal_parameters:pl SEMICOLON:s block SEMICOLON:s2
                            ;

function_declaration        ::= FUNCTION:f  IDENTIFIER:i formal_parameters:pl SEMICOLON:s block SEMICOLON:s2
                            ;

formal_parameters           ::= LPAREN parameter_defs RPAREN
                            |
                            ;

parameter_defs              ::= parameter_def:p parameter_defs:pl
                            |   parameter_def:p
                            ;

parameter_def               ::= identifier_list:il COLON:c type_identifier:t
                            ;

statements                  ::= statement:s statements:sl
                            |   statement:s
                            ;

statement                   ::= assign_statement
                            |   procedure_statement
                            |   if_statement
                            |   while_statement
                            |   repeat_statement
                            |   for_statement
                            |   write_statement
                            |   read_statement
                            |
                            ;

assign_statement            ::= variable ASSIGN expression
                            ;

procedure_statement         ::= IDENTIFIER parameter_list
                            ;

if_statement                ::= IF expression THEN statements else_statement
                            ;

else_statement              ::= ELSE statements
                            |   
                            ;

while_statement             ::= WHILE expression DO statements
                            ;

repeat_statement            ::= REPEAT statements UNTIL expression
                            ;

for_statement               ::= FOR IDENTIFIER ASSING expression TO expression DO statements
                            ;

parameter_list              ::= LPAREN parameters RPAREN
                            |   
                            ;

parameters                  ::= expression:e COMMA parameters:pl
                            |   expression:e
                            ;

OPLOG                       ::= AND
                            |   OR
                            ;

OPREL                       ::= EQ
                            |   NEQ
                            |   LT
                            |   GT
                            |   LE
                            |   GE
                            ;

OPSUM                       ::= PLUS
                            |   MINUS
                            ;

OPMULT                      ::= MULT
                            |   SLASH
                            |   DIV
                            |   MOD
                            ;

opt_expression              ::= expression:e
                            {: RESULT = e; :}
                            |
                            {: RESULT = null; :}
                            ;

expression                  ::= relation:r
                            {: RESULT = r; :}
                            |   expression:e1 OPLOG:o relation:e2
                            {: RESULT = new LogicalExpression(o, e1, e2, e1xleft.getLine(), e1xleft.getColumn()); :}
                            |   error:e
                            {: RESULT = new UndefinedExpression(exleft.getLine(), exleft.getColumn()); :}
                            ;

relation                    ::= simple_expression:e
                            {: RESULT = e; :}
                            |   simple_expression:e1 OPREL:o simple_expression:e2
                            {: RESULT = new AritmeticExpression(o, e1, e2, e1xleft.getLine(), e1xleft.getColumn()); :}
                            ;

simple_expression           ::= OPSUM:o term:t
                            {: RESULT = new UnaryExpression(o, t, oxleft.getLine(), oxleft.getColumn()); :}
                            |   term:t
                            {: RESULT = t; :}
                            |   simple_expression:e1 OPSUM:o term:e2
                            {: RESULT = new AritmeticExpression(o, e1, e2, e1xleft.getLine(), e1xleft.getColumn()); :}
                            ;

term                        ::= factor:f
                            {: RESULT = f; :}
                            |   term:e1 OPMULT:o factor:e2
                            {: RESULT = new AritmeticExpression(o, e1, e2, e1xleft.getLine(), e1xleft.getColumn()); :}
                            ;

factor                      ::= primary:p
                            {: RESULT = p; :}
                            |   NOT:n primary:p
                            {: RESULT = new NotExpression(p, nxleft.getLine(), nxleft.getColumn()); :}
                            ;

primary                     ::= name:n
                            {: RESULT = n; :}
                            |   INTEGER_LITERAL:i
                            {: RESULT = new IntegerLiteral(i.intValue(), ixleft.getLine(), ixleft.getColumn()); :}
                            |   CHAR_LITERAL:f
                            {: RESULT = new FloatLiteral(f.floatValue(), fxleft.getLine(), fxleft.getColumn()); :}
                            |   LPAREN expression:e RPAREN
                            {: RESULT = e; :}
                            |   TRUE:e
                            {: RESULT = new True(exleft.getLine(), exleft.getColumn()); :}
                            |   FALSE:e
                            {: RESULT = new False(exleft.getLine(), exleft.getColumn()); :}
                            ;

name                        ::= IDENTIFIER:i
                            {: RESULT = new IdentifierExpression(new Identifier(i, ixleft.getLine(), ixleft.getColumn()), ixleft.getLine(), ixleft.getColumn()); :}
                            |   IDENTIFIER:i LPAREN parameter_part:p RPAREN
                            {: RESULT = new CallExpression(new Identifier(i, ixleft.getLine(), ixleft.getColumn()), p, ixleft.getLine(), ixleft.getColumn()); :}
                            ;

type                        ::= type_simple:t
                            |   record_type:r
                            ;

type_simple                 ::= BOOLEAN:t
                            {: RESULT = new BooleanType(txleft.getLine(), txleft.getColumn()); :}
                            |   CHAR:t
                            {: RESULT = new CharType(txleft.getLine(), txleft.getColumn()); :}
                            |   INTEGER:t
                            {: RESULT = new IntegerType(txleft.getLine(), txleft.getColumn()); :}
                            ;